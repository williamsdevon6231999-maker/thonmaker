trigger:
- main

pool:
  name: SelfHostedWindows

variables:
  imageName: thonmaker
  acrName: thonmakeracr
  acrLoginServer: thonmakeracr.azurecr.io
  webAppName: thonmaker-app

  # DAST target (your running Azure App Service URL)
  # Example: https://thonmaker-app-auayaxh7evbug5ak.eastus2-01.azurewebsites.net
  dastTargetUrl: thonmaker-app-auayaxh7evbug5ak.eastus2-01.azurewebsites.net

steps:
# ---------------------------
# SAST – Semgrep (FAIL on findings)
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"

    chcp 65001 | Out-Null
    [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
    $env:PYTHONUTF8 = "1"
    $env:PYTHONIOENCODING = "utf-8"

    python -m pip install --upgrade pip
    python -m pip install --upgrade semgrep

    # Fail pipeline on findings at ERROR level
    semgrep scan --config=auto --severity=ERROR --error --metrics=off
  displayName: "SAST - Semgrep (Fail on ERROR)"

# ---------------------------
# Build Docker image
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"
    docker build -t $(imageName):$(Build.BuildId) .
  displayName: "Build Docker Image"

# ---------------------------
# Ensure Trivy exists (install if missing)
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"

    if (-not (Get-Command trivy -ErrorAction SilentlyContinue)) {
      if (Get-Command winget -ErrorAction SilentlyContinue) {
        winget install --id AquaSecurity.Trivy -e --accept-package-agreements --accept-source-agreements
      } else {
        Write-Host "ERROR: winget not found on this agent"
        exit 1
      }
    }

    trivy -v
  displayName: "Install / Verify Trivy"

# ---------------------------
# Trivy Image Scan (FAIL on HIGH/CRITICAL CVEs)
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"
    $env:TRIVY_CACHE_DIR = "$(Pipeline.Workspace)\trivy-cache"

    # Fail pipeline if HIGH/CRITICAL vulnerabilities are found
    trivy image --severity HIGH,CRITICAL --exit-code 1 $(imageName):$(Build.BuildId)
  displayName: "Trivy Image Scan (Fail on HIGH/CRITICAL)"

# ---------------------------
# Login to ACR using Azure CLI (uses AzureRM service connection)
# ---------------------------
- task: AzureCLI@2
  displayName: "Login to ACR"
  inputs:
    azureSubscription: sc-thonmaker-azure
    scriptType: ps
    scriptLocation: inlineScript
    inlineScript: |
      az --version
      az acr login --name $(acrName)

# ---------------------------
# Tag + Push image to ACR
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"
    docker tag $(imageName):$(Build.BuildId) $(acrLoginServer)/$(imageName):$(Build.BuildId)
    docker push $(acrLoginServer)/$(imageName):$(Build.BuildId)
  displayName: "Push Image to ACR"

# ---------------------------
# Deploy to Azure Web App (Container)
# ---------------------------
- task: AzureWebAppContainer@1
  displayName: "Deploy to Azure App Service"
  inputs:
    azureSubscription: sc-thonmaker-azure
    appName: $(webAppName)
    imageName: $(acrLoginServer)/$(imageName):$(Build.BuildId)

# ---------------------------
# DAST – OpenVAS / Greenbone (FAIL on High/Critical)
# ---------------------------
- powershell: |
    $ErrorActionPreference = "Stop"

    # Extract hostname from URL (OpenVAS targets usually want host/IP)
    $uri = [System.Uri]"$(dastTargetUrl)"
    $targetHost = $uri.Host

    Write-Host "DAST target URL: $(dastTargetUrl)"
    Write-Host "DAST target host: $targetHost"

    # Create a temp working directory
    $work = "$(Pipeline.Workspace)\openvas"
    New-Item -ItemType Directory -Force -Path $work | Out-Null
    Set-Location $work

    # --- Bring up Greenbone Community Edition (OpenVAS) via docker compose
    # This uses the official Greenbone container stack approach. (Greenbone docs)
    # NOTE: Your self-hosted agent must support Linux containers in Docker.
    $compose = @"
services:
  vulnerability-tests:
    image: greenbone/vulnerability-tests
    pull_policy: always
    volumes:
      - vt_data_vol:/mnt

  notus-data:
    image: greenbone/notus-data
    pull_policy: always
    volumes:
      - notus_data_vol:/mnt

  scap-data:
    image: greenbone/scap-data
    pull_policy: always
    volumes:
      - scap_data_vol:/mnt

  cert-bund-data:
    image: greenbone/cert-bund-data
    pull_policy: always
    volumes:
      - cert_data_vol:/mnt

  dfn-cert-data:
    image: greenbone/dfn-cert-data
    pull_policy: always
    volumes:
      - dfn_data_vol:/mnt

  data-objects:
    image: greenbone/data-objects
    pull_policy: always
    volumes:
      - data_objects_vol:/mnt

  report-formats:
    image: greenbone/report-formats
    pull_policy: always
    volumes:
      - rf_data_vol:/mnt

  gpg-data:
    image: greenbone/gpg-data
    pull_policy: always
    volumes:
      - gpg_data_vol:/mnt

  redis-server:
    image: greenbone/redis-server
    restart: on-failure
    volumes:
      - redis_socket_vol:/run/redis

  pg-gvm:
    image: greenbone/pg-gvm
    restart: on-failure
    volumes:
      - psql_data_vol:/var/lib/postgresql
      - psql_socket_vol:/var/run/postgresql

  gvmd:
    image: greenbone/gvmd
    restart: on-failure
    volumes:
      - vt_data_vol:/var/lib/openvas/plugins
      - scap_data_vol:/var/lib/gvm/scap
      - cert_data_vol:/var/lib/gvm/cert-data
      - dfn_data_vol:/var/lib/gvm/dfn-cert-data
      - data_objects_vol:/var/lib/gvm/data-objects/gvmd
      - psql_data_vol:/var/lib/postgresql
      - psql_socket_vol:/var/run/postgresql
      - gvmd_socket_vol:/run/gvmd
      - ospd_openvas_socket_vol:/run/ospd
      - redis_socket_vol:/run/redis
    depends_on:
      pg-gvm:
        condition: service_started
      redis-server:
        condition: service_started

  gsa:
    image: greenbone/gsa
    restart: on-failure
    ports:
      - 9392:80
    depends_on:
      - gvmd

  ospd-openvas:
    image: greenbone/ospd-openvas
    restart: on-failure
    volumes:
      - vt_data_vol:/var/lib/openvas/plugins
      - notus_data_vol:/var/lib/notus
      - gpg_data_vol:/etc/openvas/gnupg
      - ospd_openvas_socket_vol:/run/ospd
      - redis_socket_vol:/run/redis
    depends_on:
      redis-server:
        condition: service_started
      vulnerability-tests:
        condition: service_completed_successfully

  notus-scanner:
    image: greenbone/notus-scanner
    restart: on-failure
    volumes:
      - notus_data_vol:/var/lib/notus
      - gpg_data_vol:/etc/notus/gnupg
      - notus_scanner_socket_vol:/run/notus-scanner
    depends_on:
      notus-data:
        condition: service_completed_successfully

  gvm-tools:
    image: greenbone/gvm-tools
    volumes:
      - gvmd_socket_vol:/run/gvmd
    depends_on:
      - gvmd

volumes:
  vt_data_vol:
  notus_data_vol:
  scap_data_vol:
  cert_data_vol:
  dfn_data_vol:
  data_objects_vol:
  rf_data_vol:
  gpg_data_vol:
  redis_socket_vol:
  psql_data_vol:
  psql_socket_vol:
  gvmd_socket_vol:
  ospd_openvas_socket_vol:
  notus_scanner_socket_vol:
"@

    $compose | Out-File -Encoding utf8 -FilePath ".\docker-compose.yml"

    # Start stack
    docker compose up -d

    # Set an admin password for automation (idempotent)
    # If admin doesn't exist yet, create it; if it does, reset it.
    $adminPass = "OpenVAS!$(Build.BuildId)"
    Write-Host "Setting OpenVAS admin password for this run..."

    # Try reset password; if it fails, try create user
    docker compose exec -T gvmd gvmd --user=admin --new-password="$adminPass" 2>$null
    if ($LASTEXITCODE -ne 0) {
      docker compose exec -T gvmd gvmd --create-user=admin --password="$adminPass"
    }

    # Create target + task via GMP XML using gvm-cli over the gvmd socket
    # Then start task and poll until done, export report, and fail on High/Critical.
    $xmlCreateTarget = "<create_target><name>thonmaker-target</name><hosts>$targetHost</hosts></create_target>"
    $targetResp = docker compose run --rm gvm-tools gvm-cli --gmp-username admin --gmp-password "$adminPass" socket --xml "$xmlCreateTarget"
    if ($LASTEXITCODE -ne 0) { throw "Failed to create OpenVAS target. Response: $targetResp" }

    # Extract target_id (very simple parse)
    $targetId = ([regex]::Match($targetResp, 'id=""([^""]+)""')).Groups[1].Value
    if (-not $targetId) { throw "Could not parse target_id. Raw: $targetResp" }

    # Create task using "Full and fast" scan config if available; fallback to whatever default exists is environment-specific.
    # (If this fails, you can swap scan_config_id to a known ID from your instance.)
    $xmlCreateTask = "<create_task><name>thonmaker-dast</name><target id=""$targetId""/></create_task>"
    $taskResp = docker compose run --rm gvm-tools gvm-cli --gmp-username admin --gmp-password "$adminPass" socket --xml "$xmlCreateTask"
    if ($LASTEXITCODE -ne 0) { throw "Failed to create OpenVAS task. Response: $taskResp" }

    $taskId = ([regex]::Match($taskResp, 'id=""([^""]+)""')).Groups[1].Value
    if (-not $taskId) { throw "Could not parse task_id. Raw: $taskResp" }

    # Start task
    $xmlStart = "<start_task task_id=""$taskId""/>"
    $startResp = docker compose run --rm gvm-tools gvm-cli --gmp-username admin --gmp-password "$adminPass" socket --xml "$xmlStart"
    if ($LASTEXITCODE -ne 0) { throw "Failed to start OpenVAS task. Response: $startResp" }

    # Poll until status=Done
    Write-Host "Polling scan status..."
    while ($true) {
      Start-Sleep -Seconds 20
      $xmlGetTask = "<get_tasks task_id=""$taskId"" details=""1""/>"
      $statusResp = docker compose run --rm gvm-tools gvm-cli --gmp-username admin --gmp-password "$adminPass" socket --xml "$xmlGetTask"
      if ($LASTEXITCODE -ne 0) { throw "Failed to get OpenVAS task status. Response: $statusResp" }

      if ($statusResp -match "<status>Done</status>") { break }
      if ($statusResp -match "<status>Stopped</status>|<status>Interrupted</status>|<status>Error</status>") {
        throw "OpenVAS scan ended unexpectedly. Raw: $statusResp"
      }
      Write-Host "Scan still running..."
    }

    # Pull latest report for task (get last_report id)
    $reportId = ([regex]::Match($statusResp, 'last_report[^>]*report_id=""([^""]+)""')).Groups[1].Value
    if (-not $reportId) {
      # fallback parse common formats
      $reportId = ([regex]::Match($statusResp, '<last_report[^>]*id=""([^""]+)""')).Groups[1].Value
    }
    if (-not $reportId) { throw "Could not parse report_id from task response." }

    # Export report in XML
    $xmlGetReport = "<get_reports report_id=""$reportId"" details=""1""/>"
    $reportXml = docker compose run --rm gvm-tools gvm-cli --gmp-username admin --gmp-password "$adminPass" socket --xml "$xmlGetReport"
    $reportPath = Join-Path $work "openvas-report.xml"
    $reportXml | Out-File -Encoding utf8 -FilePath $reportPath

    # Fail on High/Critical:
    # OpenVAS uses severities (0.0–10.0). Common thresholds:
    #   Critical: 9.0–10.0
    #   High:     7.0–8.9
    $crit = Select-String -Path $reportPath -Pattern "<severity>(9\.\d|10(\.0)?)</severity>" -SimpleMatch -ErrorAction SilentlyContinue
    $high = Select-String -Path $reportPath -Pattern "<severity>(7\.\d|8\.\d)</severity>" -SimpleMatch -ErrorAction SilentlyContinue

    if ($crit -or $high) {
      Write-Host "OpenVAS found HIGH/CRITICAL vulnerabilities. Failing pipeline."
      exit 1
    }

    Write-Host "OpenVAS scan passed (no HIGH/CRITICAL found)."
  displayName: "DAST - OpenVAS (Fail on High/Critical)"
